@using PhotoSync.Domain;
@using PhotoSync.Infrastructure;
@using System.IO;
@using System.Web;
@inject AppState appState;

@if (this.photos is null || (!this.photos.Any() && !this.loading))
{
    <div>No photos found.</div>
} 
else
{
    foreach (var photo in this.photos)
    {
        <div>
            <img style="max-height: 100px; max-width: 100px" src="@this.MakePhotoUrl(photo.RelativePath)" />
            @photo.Name
        </div>
    }    
}

@code {
    private string folderPath = string.Empty;
    private bool shouldRender;
    private bool loading = true;
    private IReadOnlyList<Photo> photos;

    [Parameter]
    public string FolderPath { get; set; } = string.Empty;

    protected override void OnInitialized()
    {
        base.OnInitialized();
    }

    protected override async Task OnParametersSetAsync()
    {
        this.shouldRender = this.folderPath != this.FolderPath;
        this.folderPath = this.FolderPath;
        await this.LoadPhotos();
    }

    protected override bool ShouldRender() => this.shouldRender;

    private async Task LoadPhotos()
    {
        if (this.appState.Library is null)
        {
            return;
        }

        await this.appState.ShowLoadingModal();
        var sourceRelativePath = this.appState.Library.GetPathRelativeToSource(this.FolderPath);
        this.photos = this.appState.Library.Collection.Photos.Where(x => x.RelativeFolder == sourceRelativePath).ToList();
        await this.appState.HideLoadingModal();
    }

    private string MakePhotoUrl(string relativePath)
    {
        if (this.appState.Library is null)
        {
            return string.Empty;
        }

        var path = Path.Combine(this.appState.Library.SourceFolder, relativePath);
        var imageBytes = System.IO.File.ReadAllBytes(path);
        var base64Image = Convert.ToBase64String(imageBytes);
        return $"data:image/png;base64,{base64Image}";
    }
}
